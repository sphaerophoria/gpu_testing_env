From 23013fe817634242b232257f90660a85fcd444fc Mon Sep 17 00:00:00 2001
From: Mick Sayson <mick@sayson.com>
Date: Wed, 18 Sep 2024 21:36:05 -0700
Subject: [PATCH] Proof of concept PCI led device

---
 drivers/leds/Kconfig        |   5 ++
 drivers/leds/Makefile       |   1 +
 drivers/leds/leds-sphaero.c | 102 ++++++++++++++++++++++++++++++++++++
 3 files changed, 108 insertions(+)
 create mode 100644 drivers/leds/leds-sphaero.c

diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index 8d9d8da37..5406fe46a 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -824,8 +824,13 @@ config LEDS_BLINKM
 	help
 	  This option enables support for the BlinkM RGB LED connected
 	  through I2C. Say Y to enable support for the BlinkM LED.
 
+config LEDS_SPHAERO
+	tristate "LED support for sphaero leds"
+	depends on LEDS_CLASS
+	depends on PCI
+
 config LEDS_POWERNV
 	tristate "LED support for PowerNV Platform"
 	depends on LEDS_CLASS
 	depends on PPC_POWERNV
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index 18afbb5a2..bc489bff3 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -91,8 +91,9 @@ obj-$(CONFIG_LEDS_TPS6105X)		+= leds-tps6105x.o
 obj-$(CONFIG_LEDS_TURRIS_OMNIA)		+= leds-turris-omnia.o
 obj-$(CONFIG_LEDS_WM831X_STATUS)	+= leds-wm831x-status.o
 obj-$(CONFIG_LEDS_WM8350)		+= leds-wm8350.o
 obj-$(CONFIG_LEDS_WRAP)			+= leds-wrap.o
+obj-$(CONFIG_LEDS_SPHAERO)		+= leds-sphaero.o
 
 # Kinetic ExpressWire Protocol
 obj-$(CONFIG_LEDS_EXPRESSWIRE)		+= leds-expresswire.o
 
diff --git a/drivers/leds/leds-sphaero.c b/drivers/leds/leds-sphaero.c
new file mode 100644
index 000000000..dc10b0ce6
--- /dev/null
+++ b/drivers/leds/leds-sphaero.c
@@ -0,0 +1,102 @@
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/leds.h>
+
+#define DRV_NAME		"sphaero"
+#define PCI_VENDOR_ID_SPHAERO	0xaaaa
+#define PCI_DEVICE_ID_SPHAERO	0xaaaa
+
+static const struct pci_device_id pci_table[] = {
+        { PCI_DEVICE(PCI_VENDOR_ID_SPHAERO,     PCI_DEVICE_ID_SPHAERO), },
+        { },
+};
+
+
+struct sphaero_priv {
+	uint32_t* regs;
+	struct led_classdev r_cdev;
+	struct led_classdev g_cdev;
+	struct led_classdev b_cdev;
+};
+
+static int sphaero_red_set(struct led_classdev *led_cdev,
+			       enum led_brightness brightness) {
+	struct sphaero_priv* s = container_of(led_cdev, struct sphaero_priv, r_cdev);
+	writel((u8)brightness, s->regs);
+	return 0;
+}
+
+static int sphaero_green_set(struct led_classdev *led_cdev,
+			       enum led_brightness brightness) {
+	struct sphaero_priv* s = container_of(led_cdev, struct sphaero_priv, g_cdev);
+	writel((u8)brightness, s->regs + 1);
+	return 0;
+}
+
+static int sphaero_blue_set(struct led_classdev *led_cdev,
+			       enum led_brightness brightness) {
+	struct sphaero_priv* s = container_of(led_cdev, struct sphaero_priv, b_cdev);
+	writel((u8)brightness, s->regs + 2);
+	return 0;
+}
+
+static int sphaero_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	int rc = 0;
+	printk("yo yo yo, whats up whats up whats up\n");
+
+	rc = pci_enable_device(pdev);
+	if (rc) {
+		goto err;
+	}
+
+	rc = pci_request_regions(pdev, DRV_NAME);
+	if (rc)
+		goto err_regions;
+
+	resource_size_t pciaddr = pci_resource_start(pdev, 0);
+	uint32_t* regs = ioremap(pciaddr, 32);
+
+	struct sphaero_priv* priv = devm_kzalloc(&pdev->dev, sizeof(struct sphaero_priv), GFP_KERNEL);
+	priv->regs = regs;
+	priv->r_cdev.name = "sphaero:red";
+	priv->r_cdev.max_brightness = 255;
+	priv->r_cdev.brightness_set_blocking = sphaero_red_set;
+	rc = led_classdev_register(&pdev->dev, &priv->r_cdev);
+	// FIXME: free/err
+
+	priv->g_cdev.name = "sphaero:green";
+	priv->g_cdev.max_brightness = 255;
+	priv->g_cdev.brightness_set_blocking = sphaero_green_set;
+	rc = led_classdev_register(&pdev->dev, &priv->g_cdev);
+	// FIXME: free/err
+
+	priv->b_cdev.name = "sphaero:blue";
+	priv->b_cdev.max_brightness = 255;
+	priv->b_cdev.brightness_set_blocking = sphaero_blue_set;
+	rc = led_classdev_register(&pdev->dev, &priv->b_cdev);
+	// FIXME: free/err
+
+	writel(5, priv->regs);
+	writel(6, priv->regs + 1);
+	writel(7, priv->regs + 2);
+
+	int r = readl(priv->regs);
+	int g = readl(priv->regs + 1);
+	int b = readl(priv->regs + 2);
+	printk("Got %d %d %d", r, g, b);
+	return 0;
+
+err_regions:
+	pci_disable_device(pdev);
+err:
+	return rc;
+}
+
+static struct pci_driver sphaero_driver = {
+	.name         = DRV_NAME,
+	.id_table     = pci_table,
+	.probe        =	sphaero_probe,
+};
+
+module_pci_driver(sphaero_driver);
-- 
2.44.1

